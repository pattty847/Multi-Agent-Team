Project Export - src
Generated on: 2024-10-27 02:03:50
==================================================

ðŸ“ .
    ðŸ“„ __init__.py
        File Contents:
        ==================================================
        ==================================================

    ðŸ“„ docker_workspace.py
        File Contents:
        ==================================================
        import os
        from typing import Dict, List, Optional
        import logging
        import docker
        from pathlib import Path
        
        class DockerWorkspaceManager:
            """Manages persistent Docker workspace and package caching"""
            
            def __init__(self, base_dir: str = "docker_workspace"):
                self.base_dir = Path(base_dir)
                self.volumes_dir = self.base_dir / "volumes"
                self.packages_dir = self.base_dir / "packages"
                self.workspace_dir = self.base_dir / "workspace"
                self.docker_client = docker.from_env()
                
                # Create necessary directories
                self.volumes_dir.mkdir(parents=True, exist_ok=True)
                self.packages_dir.mkdir(parents=True, exist_ok=True)
                self.workspace_dir.mkdir(parents=True, exist_ok=True)
                
                # Create or get volume names
                self.pip_cache_volume = "pip_cache_volume"
                self.workspace_volume = "workspace_volume"
                
            def ensure_volumes(self):
                """Ensure Docker volumes exist"""
                try:
                    # Create pip cache volume if it doesn't exist
                    try:
                        self.docker_client.volumes.get(self.pip_cache_volume)
                    except docker.errors.NotFound:
                        self.docker_client.volumes.create(
                            name=self.pip_cache_volume,
                            driver='local'
                        )
                        
                    # Create workspace volume if it doesn't exist
                    try:
                        self.docker_client.volumes.get(self.workspace_volume)
                    except docker.errors.NotFound:
                        self.docker_client.volumes.create(
                            name=self.workspace_volume,
                            driver='local'
                        )
                        
                except Exception as e:
                    logging.error(f"Error ensuring Docker volumes: {e}")
                    raise
        
            def get_volume_config(self) -> Dict:
                """Get Docker volume configuration for code execution"""
                return {
                    "use_docker": True,
                    "work_dir": str(self.workspace_dir),
                    "volumes": {
                        self.pip_cache_volume: {
                            "bind": "/root/.cache/pip",
                            "mode": "rw"
                        },
                        self.workspace_volume: {
                            "bind": "/workspace",
                            "mode": "rw"
                        }
                    }
                }
        
            async def cleanup_unused(self):
                """Clean up unused containers while preserving volumes"""
                try:
                    containers = self.docker_client.containers.list(
                        all=True,
                        filters={
                            "label": "created_by=enhanced_code_agent",
                            "status": "exited"
                        }
                    )
                    
                    for container in containers:
                        try:
                            container.remove()
                            logging.info(f"Removed unused container: {container.id}")
                        except Exception as e:
                            logging.warning(f"Error removing container {container.id}: {e}")
                            
                except Exception as e:
                    logging.error(f"Error during cleanup: {e}")
        
            def close(self):
                """Close Docker client"""
                if self.docker_client:
                    self.docker_client.close()        ==================================================

    ðŸ“„ team_task.py
        File Contents:
        ==================================================
        # src/team_tasks.py
        from typing import List, Dict
        from .agents.specialized import TeamManager
        from .config import SystemConfig
        from autogen import GroupChat, GroupChatManager
        
        class GroupTaskManager:
            """Manages group tasks and agent interactions"""
            def __init__(self, config: SystemConfig, executor):
                self.team_manager = TeamManager(config, executor)
                self.config = config
                
            def create_group_chat(self, agents: List[str], task: str) -> tuple:
                """Create a group chat with specified agents"""
                # Get requested agents
                selected_agents = [
                    self.team_manager.get_agent(role)
                    for role in agents
                    if self.team_manager.get_agent(role)
                ]
                
                # Create group chat with updated configuration based on latest AutoGen API
                group_chat = GroupChat(
                    agents=selected_agents,
                    messages=[],
                    max_round=50,
                    send_introductions=True,  # Agents will introduce themselves
                )
                
                # Create chat manager with updated configuration
                manager = GroupChatManager(
                    groupchat=group_chat,
                    llm_config={"config_list": self.config.llm_config_list},
                    system_message="""You are a group chat manager coordinating a team of AI agents.
                    Help them work together effectively to solve the given task.
                    Ensure each agent contributes according to their expertise.""",
                )
                
                return manager, group_chat
        
            def format_task(self, task: str) -> str:
                """Format task message with clear instructions"""
                return f"""
                TASK DESCRIPTION:
                {task}
                
                COLLABORATION GUIDELINES:
                1. Project Manager (pm) should coordinate the overall effort
                2. Each specialist should contribute based on their expertise
                3. Maintain clear communication and documentation
                4. Verify results and quality at each step
                
                EXPECTED OUTCOMES:
                1. Clear documentation of the process
                2. Quality-assured results
                3. Proper testing and validation
                4. Performance considerations
                
                Please begin with task planning and proceed with execution.
                """
            
            def execute_task(self, task: str, required_agents: List[str]) -> Dict:
                """Execute a task using the specified agents"""
                try:
                    # Create group chat
                    manager, chat = self.create_group_chat(required_agents, task)
                    
                    # Format task message
                    formatted_task = self.format_task(task)
                    
                    # Get the first agent to initiate the chat
                    initiator = chat.agents[0]
                    
                    # Start the group chat with the first agent as initiator
                    chat_result = initiator.initiate_chat(
                        recipient=manager,
                        message=formatted_task,
                    )
                    
                    return {
                        "result": chat_result,
                        "chat_history": chat.messages,
                        "participants": [agent.name for agent in chat.agents]
                    }
                    
                except Exception as e:
                    print(f"\nError during task execution: {str(e)}")
                    return {
                        "error": str(e),
                        "participants": [agent.name for agent in chat.agents] if 'chat' in locals() else [],
                        "status": "failed"
                    }        ==================================================

    ðŸ“„ utils.py
        File Contents:
        ==================================================
        import logging
        from typing import Optional
        import signal
        import logging
        from typing import Optional
        
        from src.agents import EnhancedUserProxy
        from src.core.config import SystemConfig
        from src.core.executor import EnhancedDockerExecutor
        
        class GracefulExitHandler:
            def __init__(self):
                self.exit_now = False
                signal.signal(signal.SIGINT, self.exit_gracefully)
                signal.signal(signal.SIGTERM, self.exit_gracefully)
        
            def exit_gracefully(self, *args):
                self.exit_now = True
                print("\nReceived exit signal. Cleaning up...")
                
        # Main application
        
        def setup_logging():
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
        
        class MultiAgentSystem:
            def __init__(self, config: Optional[SystemConfig] = None):
                self.config = config or SystemConfig()
                self.exit_handler = GracefulExitHandler()
                self.executor = EnhancedDockerExecutor(
                    image=self.config.DOCKER_IMAGE,
                    timeout=self.config.CODE_TIMEOUT,
                    workspace=self.config.WORKING_DIR
                )
                self.assistant = EnhancedAssistantAgent("assistant", self.config)
                self.user_proxy = EnhancedUserProxy("user_proxy", self.executor)
                setup_logging()
        
            def run_task(self, task_message: str, save_history: bool = True) -> None:
                try:
                    self.user_proxy.initiate_chat(
                        self.assistant,
                        message=task_message
                    )
                    if save_history:
                        self.user_proxy.save_conversation("conversation_history.txt")
                except KeyboardInterrupt:
                    print("\nGracefully shutting down...")
                except Exception as e:
                    logging.error(f"Error during task execution: {e}")
                finally:
                    self.cleanup()
        
            def cleanup(self):
                try:
                    self.executor.stop()
                except Exception as e:
                    logging.error(f"Error during cleanup: {e}")
        ==================================================

    ðŸ“ agents
        ðŸ“„ __init__.py
            File Contents:
            ==================================================
            # src/agents/__init__.py
            from .base import BaseAssistantAgent
            from .specialized import (
                ResearchAgent,
                CodeExpertAgent,
                DataVisualizationAgent,
                ProjectManagerAgent,
                QAAgent,
                TeamManager
            )
            from .user_proxy import EnhancedUserProxy
            from .web_agent import WebResearchAgent
            
            __all__ = [
                'BaseAssistantAgent',
                'ResearchAgent',
                'CodeExpertAgent',
                'DataVisualizationAgent',
                'ProjectManagerAgent',
                'QAAgent',
                'TeamManager',
                'EnhancedUserProxy',
                'WebResearchAgent',
            ]            ==================================================

        ðŸ“„ base.py
            File Contents:
            ==================================================
            # src/agents/base.py
            from typing import Optional, Dict
            from autogen import AssistantAgent, ConversableAgent
            from src.core.config import SystemConfig
            
            class BaseAssistantAgent(AssistantAgent):
                """Base class for all assistant agents with common functionality"""
                def __init__(
                    self,
                    name: str,
                    system_message: str,
                    config: SystemConfig
                ):
                    super().__init__(
                        name=name,
                        system_message=system_message,
                        llm_config={"config_list": config.llm_config_list}
                    )
                    self.config = config
            
                def save_response(self, response: str, filename: str):
                    """Save agent response to file"""
                    with open(filename, 'a') as f:
                        f.write(f"\n{self.name}: {response}\n")            ==================================================

        ðŸ“„ specialized.py
            File Contents:
            ==================================================
            # src/agents/specialized.py
            from typing import Dict, List, Optional
            from autogen import AssistantAgent, ConversableAgent
            from autogen import GroupChat, GroupChatManager
            from src.agents.base import BaseAssistantAgent
            from typing import Dict, List, Any, Optional, Callable
            from autogen import ConversableAgent
            from autogen.agentchat import UserProxyAgent
            import docker
            import logging
            import os
            from pathlib import Path
            
            from src.core.config import SystemConfig
            
            logger = logging.getLogger(__name__)
            
            class SpecializedCodeAgent(ConversableAgent):
                """
                An enhanced CodeExpertAgent that specializes in code generation, review, and execution
                using Docker containers for isolation and safety.
                """
                
                DEFAULT_CONFIG = {
                    "temperature": 0.1,  # Lower temperature for more focused code generation
                    "model": "gpt-4o",  # Using latest model for better code understanding
                    "timeout": 600,  # 10 minute timeout for complex operations
                }
            
                DEFAULT_SYSTEM_MESSAGE = """You are an expert software developer with deep knowledge of 
                software architecture, design patterns, and best practices. Your role is to:
                1. Write high-quality, well-documented code
                2. Review and improve existing code
                3. Suggest architectural improvements
                4. Execute and test code safely in containers
                5. Explain technical concepts clearly
                
                Always follow these principles:
                - Write secure, efficient, and maintainable code
                - Provide clear documentation and explanations
                - Use appropriate design patterns and best practices
                - Consider scalability and performance implications
                """
            
                def __init__(
                    self,
                    name: str = "CodeExpert",
                    human_input_mode: str = "TERMINATE",
                    system_message: Optional[str] = DEFAULT_SYSTEM_MESSAGE,
                    llm_config: Optional[Dict] = None,
                    code_execution_config: Optional[Dict] = None,
                    **kwargs
                ):
                    """Initialize the CodeExpertAgent with enhanced capabilities."""
                    
                    # Setup base configuration
                    self.code_execution_config = {
                        "work_dir": "./workspace",
                        "use_docker": True,
                        "timeout": 300,
                        "last_n_messages": 3,
                    }
                    
                    # Initialize Docker client if using containers
                    self.docker_client = docker.from_env() if self.code_execution_config["use_docker"] else None
                    
                    # Setup workspace directory
                    self.workspace_dir = Path(self.code_execution_config["work_dir"])
                    self.workspace_dir.mkdir(parents=True, exist_ok=True)
                    
                    # Create UserProxyAgent for code execution
                    self.executor = UserProxyAgent(
                        name="CodeExecutor",
                        human_input_mode="NEVER",
                        code_execution_config=self.code_execution_config,
                        system_message="I am a code execution agent. I run code safely and return results."
                    )
            
                    # Initialize with parent class
                    super().__init__(
                        name=name,
                        system_message=system_message,
                        human_input_mode=human_input_mode,
                        llm_config=llm_config or self.DEFAULT_CONFIG,
                        code_execution_config=False,  # We handle code execution ourselves
                        **kwargs
                    )
            
                    # Register message handlers
                    self.register_reply(
                        trigger=self._is_code_execution_request,
                        reply_func=self._handle_code_execution
                    )
                    self.register_reply(
                        trigger=self._is_code_review_request,
                        reply_func=self._handle_code_review
                    )
            
                def _is_code_execution_request(self, message: Dict) -> bool:
                    """Determine if the message is requesting code execution."""
                    content = message.get("content", "").lower()
                    execution_keywords = {"run", "execute", "test", "try", "run this"}
                    return any(keyword in content for keyword in execution_keywords)
            
                def _is_code_review_request(self, message: Dict) -> bool:
                    """Determine if the message is requesting code review."""
                    content = message.get("content", "").lower()
                    review_keywords = {"review", "check", "analyze", "improve", "optimize"}
                    return any(keyword in content for keyword in review_keywords)
            
                async def _handle_code_execution(self, message: Dict) -> str:
                    """Handle code execution requests safely using UserProxyAgent."""
                    try:
                        # Extract code from message
                        code = self._extract_code(message["content"])
                        if not code:
                            return "No executable code found in the message."
            
                        # Prepare execution environment
                        container_config = self._prepare_container_config()
                        
                        # Execute code through UserProxyAgent
                        result = await self.executor.execute_code(
                            code,
                            work_dir=self.workspace_dir,
                            use_docker=True,
                            container_config=container_config
                        )
            
                        return self._format_execution_result(result)
            
                    except Exception as e:
                        logger.error(f"Code execution error: {str(e)}")
                        return f"Error executing code: {str(e)}"
            
                async def _handle_code_review(self, message: Dict) -> str:
                    """Handle code review requests."""
                    try:
                        code = self._extract_code(message["content"])
                        if not code:
                            return "No code found to review."
            
                        # Analyze code using LLM
                        review_prompt = self._create_review_prompt(code)
                        review_result = await self.generate_response(review_prompt)
            
                        return review_result
            
                    except Exception as e:
                        logger.error(f"Code review error: {str(e)}")
                        return f"Error reviewing code: {str(e)}"
            
                def _extract_code(self, content: str) -> Optional[str]:
                    """Extract code blocks from message content."""
                    import re
                    code_blocks = re.findall(r'```(?:\w+)?\n(.*?)```', content, re.DOTALL)
                    return code_blocks[0] if code_blocks else None
            
                def _prepare_container_config(self) -> Dict:
                    """Prepare Docker container configuration for code execution."""
                    return {
                        "image": "python:3.9-slim",
                        "command": "python",
                        "volumes": {
                            str(self.workspace_dir.absolute()): {
                                'bind': '/workspace',
                                'mode': 'rw'
                            }
                        },
                        "working_dir": "/workspace",
                        "network_disabled": True,
                        "mem_limit": "512m",
                        "cpu_period": 100000,
                        "cpu_quota": 50000
                    }
            
                def _format_execution_result(self, result: Dict) -> str:
                    """Format the execution result for display."""
                    output = ["Code Execution Result:"]
                    
                    if "output" in result:
                        output.append("\nOutput:")
                        output.append(result["output"])
                    
                    if "error" in result:
                        output.append("\nErrors:")
                        output.append(result["error"])
                    
                    if "execution_time" in result:
                        output.append(f"\nExecution Time: {result['execution_time']:.2f} seconds")
            
                    return "\n".join(output)
            
                def _create_review_prompt(self, code: str) -> str:
                    """Create a prompt for code review analysis."""
                    return f"""Please review the following code focusing on:
                    1. Code quality and best practices
                    2. Security considerations
                    3. Performance optimizations
                    4. Maintainability improvements
                    5. Potential bugs or issues
            
                    Code to review:
                    ```python
                    {code}
                    ```
            
                    Provide specific recommendations and explanations for each point."""
            
                async def generate_response(self, prompt: str) -> str:
                    """Generate a response using the configured LLM."""
                    response = await super().generate_response(prompt)
                    return response
            
                def cleanup(self):
                    """Cleanup resources when done."""
                    if self.docker_client:
                        self.docker_client.close()
                        
            class CodeExpertAgent(AssistantAgent):
                """Specializes in code analysis, optimization, and best practices"""
                def __init__(self, config: SystemConfig):
                    super().__init__(
                        name="code_expert",
                        system_message="""You are a code expert specialized in:
                        1. Code review and optimization
                        2. Best practices and design patterns
                        3. Performance analysis
                        4. Security review
                        
                        When analyzing code:
                        1. First identify potential issues
                        2. Suggest specific improvements
                        3. Provide example code when helpful
                        4. Consider both functionality and maintainability""",
                        llm_config=config.llm_config
                    )
            
            class ResearchAgent(AssistantAgent):
                """Specializes in academic research and paper analysis"""
                def __init__(self, config: SystemConfig):
                    super().__init__(
                        name="research_assistant",
                        system_message="""You are a research specialist focused on analyzing academic papers and research findings.
                        Your strengths include:
                        1. Summarizing complex research papers
                        2. Identifying key findings and methodologies
                        3. Comparing different research approaches
                        4. Suggesting relevant papers and citations
                        
                        Always structure your responses clearly and cite sources when available.
                        Include links to papers when possible.""",
                        llm_config=config.llm_config
                    )
            
            class DataVisualizationAgent(AssistantAgent):
                """Specializes in creating and explaining data visualizations"""
                def __init__(self, config: SystemConfig):
                    super().__init__(
                        name="visualization_expert",
                        system_message="""You are a data visualization specialist who excels at:
                        1. Creating clear and informative visualizations
                        2. Choosing appropriate chart types
                        3. Color theory and accessibility
                        4. Interactive visualization design
                        
                        Always consider:
                        1. The target audience
                        2. The story the data tells
                        3. Best practices in visualization
                        4. Performance and interactivity""",
                        llm_config=config.llm_config
                    )
            
            class ProjectManagerAgent(AssistantAgent):
                """Coordinates tasks and manages workflow between agents"""
                def __init__(self, config: SystemConfig):
                    super().__init__(
                        name="project_manager",
                        system_message="""You are a project manager responsible for:
                        1. Task coordination between different agents
                        2. Workflow optimization
                        3. Progress tracking
                        4. Resource allocation
                        
                        Your role is to:
                        1. Break down complex tasks
                        2. Assign work to appropriate specialists
                        3. Monitor progress and handle blockers
                        4. Ensure quality and completeness""",
                        llm_config=config.llm_config
                    )
            
            class QAAgent(AssistantAgent):
                """Specializes in testing and quality assurance"""
                def __init__(self, config: SystemConfig):
                    super().__init__(
                        name="qa_expert",
                        system_message="""You are a QA specialist focused on:
                        1. Test case design
                        2. Edge case identification
                        3. Performance testing
                        4. User experience testing
                        
                        Always:
                        1. Think about potential failure modes
                        2. Consider different user scenarios
                        3. Verify requirements are met
                        4. Document test results clearly""",
                        llm_config=config.llm_config
                    )
            
            class TeamManager:
                """Manages a team of specialized agents"""
                def __init__(self, config: SystemConfig, executor):
                    self.config = config
                    self.executor = executor
                    self.agents = self._initialize_agents()
                    
                def _initialize_agents(self) -> Dict[str, AssistantAgent]:
                    """Initialize all specialized agents"""
                    return {
                        "research": ResearchAgent(self.config),
                        "code": CodeExpertAgent(self.config),
                        "viz": DataVisualizationAgent(self.config),
                        "pm": ProjectManagerAgent(self.config),
                        "qa": QAAgent(self.config)
                    }
                
                def get_agent(self, role: str) -> Optional[AssistantAgent]:
                    """Get an agent by their role"""
                    return self.agents.get(role)
                
                def get_all_agents(self) -> List[AssistantAgent]:
                    """Get all agents"""
                    return list(self.agents.values())
            
                def execute_group_task(
                    self, 
                    task_description: str, 
                    agents: List[AssistantAgent],
                    max_rounds: int = 10
                ) -> Dict:
                    """Execute a task using a group of agents"""
                    try:
                        # Ensure we have at least one agent
                        if not agents:
                            raise ValueError("At least one agent is required for group task execution")
                            
                        # Add project manager if not present
                        if self.agents["pm"] not in agents:
                            agents = [self.agents["pm"]] + list(agents)
                            
                        # Create group chat
                        groupchat = GroupChat(
                            agents=agents,
                            messages=[],
                            max_round=max_rounds
                        )
                        
                        # Create chat manager
                        manager = GroupChatManager(
                            groupchat=groupchat,
                            llm_config=self.config.llm_config,
                            system_message=f"""Coordinate the completion of this task:
                            {task_description}
                            
                            Ensure each agent contributes according to their expertise.
                            The project manager should coordinate the overall effort.
                            Verify results before marking the task as complete."""
                        )
                        
                        # Start the group chat
                        chat_result = agents[0].initiate_chat(
                            manager,
                            message=task_description
                        )
                        
                        return {
                            "success": True,
                            "chat_history": groupchat.messages,
                            "result": chat_result
                        }
                        
                    except Exception as e:
                        logger.error(f"Error during group task execution: {e}")
                        return {
                            "success": False,
                            "error": str(e),
                            "chat_history": []
                        }
            
                def execute_sequential_tasks(
                    self, 
                    tasks: List[Dict],
                    required_agents: List[str]
                ) -> List[Dict]:
                    """Execute a sequence of related tasks"""
                    results = []
                    
                    # Get required agents
                    agents = [
                        self.get_agent(role)
                        for role in required_agents
                        if self.get_agent(role) is not None
                    ]
                    
                    # Execute each task in sequence
                    for task in tasks:
                        result = self.execute_group_task(
                            task_description=task["description"],
                            agents=agents,
                            max_rounds=task.get("max_rounds", 10)
                        )
                        results.append(result)
                        
                        # Break if a task fails
                        if not result["success"]:
                            break
                            
                    return results            ==================================================

        ðŸ“„ user_proxy.py
            File Contents:
            ==================================================
            # src/agents/user_proxy.py
            from typing import Optional, Dict
            from autogen import UserProxyAgent
            from src.core.config import SystemConfig
            
            class EnhancedUserProxy(UserProxyAgent):
                """Enhanced user proxy with better termination handling and history"""
                def __init__(self, name: str, executor, human_input_mode: str = "TERMINATE"):
                    super().__init__(
                        name=name,
                        code_execution_config={"executor": executor},
                        human_input_mode=human_input_mode,
                        is_termination_msg=self._is_termination_msg
                    )
                    self.conversation_history = []
                    
                def _is_termination_msg(self, msg: Dict) -> bool:
                    """Check if message indicates task completion"""
                    if not msg.get("content"):
                        return False
                        
                    content = msg["content"].upper()
                    return any(phrase in content for phrase in [
                        "TERMINATE",
                        "TASK_COMPLETED",
                        "TASK TERMINATED BY USER"
                    ])
            
                def generate_reply(self, messages: list, sender: Optional[object] = None, **kwargs):
                    """Generate reply with history tracking"""
                    try:
                        reply = super().generate_reply(messages, sender, **kwargs)
                        
                        # Store in history if it's not a termination message
                        if not self._is_termination_msg({"content": reply}):
                            self.conversation_history.append({
                                "sender": sender.name if sender else "system",
                                "message": messages[-1]["content"],
                                "reply": reply
                            })
                        return reply
                        
                    except Exception as e:
                        print(f"\nError during reply generation: {str(e)}")
                        return f"Error occurred: {str(e)}"            ==================================================

        ðŸ“„ web_agent.py
            File Contents:
            ==================================================
            # src/agents/web_agent.py
            from typing import Dict
            
            from tools.web_search import WebSearchTool
            from .base import BaseAssistantAgent
            
            class WebResearchAgent(BaseAssistantAgent):
                """Agent specialized in web research with integrated search capabilities"""
                def __init__(self, config):
                    super().__init__(
                        name="web_researcher",
                        system_message="""You are a web research specialist who can:
                        1. Search for recent academic papers and research
                        2. Analyze and summarize findings
                        3. Compare different sources
                        4. Identify key trends and developments
                        
                        Always cite sources and provide links when available.""",
                        config=config
                    )
                    self.search_tool = WebSearchTool()
                
                def research(self, query: str) -> Dict:
                    """Perform research on a given query"""
                    return self.search_tool.summarize_research(query)            ==================================================

    ðŸ“ core
        ðŸ“„ config.py
            File Contents:
            ==================================================
            from dataclasses import dataclass, field
            from typing import Dict, List
            import os
            
            @dataclass
            class SystemConfig:
                """Core system configuration with LLM settings"""
                OPENAI_API_KEY: str = field(default_factory=lambda: os.getenv("OPENAI_API_KEY"))
                DEFAULT_MODEL: str = "gpt-4o"
                DOCKER_IMAGE: str = "python:3.9-slim"
                CODE_TIMEOUT: int = 60
                WORKING_DIR: str = "workspace"
                
                def __post_init__(self):
                    # Configure LLM settings for autogen
                    self.llm_config = {
                        "config_list": [{
                            "model": self.DEFAULT_MODEL,
                            "api_key": self.OPENAI_API_KEY,
                        }],
                        "temperature": 0.7,
                        "timeout": 600,
                        "cache_seed": None  # Disable caching for now
                    }            ==================================================

        ðŸ“„ delegation.py
            File Contents:
            ==================================================
            # src/task_decomposition.py
            from typing import List, Dict, Optional
            from dataclasses import dataclass
            from .agents.specialized import TeamManager
            from autogen import AssistantAgent
            
            @dataclass
            class SubTask:
                """Represents a decomposed subtask"""
                description: str
                required_agents: List[str]
                dependencies: List[str]  # IDs of tasks that must be completed first
                status: str = "pending"  # pending, in_progress, completed, failed
                result: Optional[str] = None
                id: Optional[str] = None
            
            # src/task_decomposition.py
            
            class TaskDecomposer:
                """Breaks down complex tasks into manageable subtasks"""
                
                def __init__(self, config, team_manager: TeamManager):
                    self.config = config
                    self.team_manager = team_manager
                    
                    # Create the decomposer agent
                    self.decomposer = AssistantAgent(
                        name="task_decomposer",
                        system_message="""You are an expert at breaking down complex tasks into smaller, manageable subtasks.
                        For each subtask, provide:
                        1. A clear description
                        2. Required agent types (must include at least one of: research, code, viz, qa, pm)
                        3. Any dependencies on other subtasks
                        
                        Format each subtask as:
                        ### Subtask [number]: [title]
                        Description: [detailed description]
                        Required Agents: [comma-separated list of required agents]
                        Dependencies: [comma-separated list of subtask numbers or 'none']
                        
                        Example:
                        ### Subtask 1: Research Latest Papers
                        Description: Gather and analyze recent research papers on the topic
                        Required Agents: research, qa
                        Dependencies: none
                        
                        Available agent types:
                        - research: For gathering and analyzing information
                        - code: For programming and technical tasks
                        - viz: For data visualization and presentation
                        - qa: For quality assurance and testing
                        - pm: For project management and coordination""",
                        llm_config={"config_list": config.llm_config_list}
                    )
                
                def decompose_task(self, task: str) -> List[SubTask]:
                    """Decompose a complex task into subtasks"""
                    
                    # Ask the decomposer to analyze the task
                    response = self.decomposer.generate_reply(
                        messages=[{
                            "role": "user",
                            "content": f"""Please break down this task into subtasks:
                            {task}
                            
                            Follow the format specified in your instructions, ensuring each subtask
                            has required agents and dependencies clearly specified."""
                        }]
                    )
                    
                    # Parse the response into SubTask objects
                    subtasks = self._parse_decomposition(response)
                    
                    # Validate subtasks
                    self._validate_subtasks(subtasks)
                    
                    return subtasks
                
                def _parse_decomposition(self, response: str) -> List[SubTask]:
                    """Parse the decomposer's response into SubTask objects"""
                    subtasks = []
                    current_subtask = None
                    
                    for line in response.split('\n'):
                        line = line.strip()
                        if not line:
                            continue
                            
                        if line.startswith('### Subtask'):
                            # Save previous subtask if exists
                            if current_subtask and current_subtask.description:
                                subtasks.append(current_subtask)
                            
                            # Create new subtask
                            current_subtask = SubTask(
                                description="",
                                required_agents=[],
                                dependencies=[],
                                id=f"task_{len(subtasks)}"
                            )
                            # Add title to description
                            current_subtask.description = line.split(':', 1)[1].strip() + "\n"
                            
                        elif current_subtask:
                            if line.lower().startswith('description:'):
                                desc = line.split(':', 1)[1].strip()
                                current_subtask.description += desc + "\n"
                                
                            elif line.lower().startswith('required agents:'):
                                agents = line.split(':', 1)[1].strip()
                                current_subtask.required_agents = [
                                    a.strip().lower() for a in agents.split(',')
                                    if a.strip()
                                ]
                                
                            elif line.lower().startswith('dependencies:'):
                                deps = line.split(':', 1)[1].strip()
                                if deps.lower() != 'none':
                                    current_subtask.dependencies = [
                                        f"task_{int(d.strip())-1}" 
                                        for d in deps.split(',')
                                        if d.strip().isdigit()
                                    ]
                            
                            else:
                                # Add to description
                                current_subtask.description += line + "\n"
                    
                    # Add the last subtask
                    if current_subtask and current_subtask.description:
                        subtasks.append(current_subtask)
                        
                    return subtasks
                
                def _validate_subtasks(self, subtasks: List[SubTask]):
                    """Validate that subtasks are properly formed"""
                    for task in subtasks:
                        # Ensure each task has at least one agent
                        if not task.required_agents:
                            raise ValueError(f"Task {task.id} has no required agents specified")
                        
                        # Validate agent types
                        valid_agents = {'research', 'code', 'viz', 'qa', 'pm'}
                        invalid_agents = set(task.required_agents) - valid_agents
                        if invalid_agents:
                            raise ValueError(f"Task {task.id} has invalid agent types: {invalid_agents}")
                        
                        # Validate dependencies
                        for dep in task.dependencies:
                            if not any(t.id == dep for t in subtasks):
                                raise ValueError(f"Task {task.id} has invalid dependency: {dep}")
            
            
            class TaskExecutor:
                """Executes decomposed tasks using the appropriate agents"""
                
                def __init__(self, team_manager: TeamManager):
                    self.team_manager = team_manager
                    self.completed_tasks: Dict[str, SubTask] = {}
                    
                def execute_subtasks(self, subtasks: List[SubTask]) -> Dict[str, Dict]:
                    """Execute a list of subtasks in the correct order"""
                    results = {}
                    
                    while subtasks:
                        # Find tasks that can be executed (all dependencies met)
                        ready_tasks = [
                            task for task in subtasks
                            if all(dep in self.completed_tasks for dep in task.dependencies)
                        ]
                        
                        if not ready_tasks:
                            raise Exception("Dependency cycle detected or no tasks ready")
                        
                        # Execute ready tasks
                        for task in ready_tasks:
                            print(f"\nExecuting task: {task.description}")
                            
                            # Get the required agents
                            agents = [
                                self.team_manager.get_agent(role)
                                for role in task.required_agents
                                if self.team_manager.get_agent(role) is not None
                            ]
                            
                            try:
                                # Execute the task with the group
                                result = self.team_manager.execute_group_task(
                                    task_description=task.description,
                                    agents=agents
                                )
                                
                                # Store the result
                                if result["success"]:
                                    task.status = "completed"
                                    self.completed_tasks[task.id] = task
                                else:
                                    task.status = "failed"
                                
                                results[task.id] = {
                                    "status": task.status,
                                    "result": result,
                                    "description": task.description,
                                    "agents": [agent.name for agent in agents]
                                }
                                
                            except Exception as e:
                                print(f"Task failed: {str(e)}")
                                task.status = "failed"
                                results[task.id] = {
                                    "status": "failed",
                                    "error": str(e),
                                    "description": task.description,
                                    "agents": [agent.name for agent in agents]
                                }
                            
                            # Remove completed/failed task from the list
                            subtasks.remove(task)
                            
                            # Print progress
                            print(f"Task {task.id} {task.status}")
                    
                    return results
                
                
            def decompose_and_execute(
                task: str,
                config,
                team_manager: TeamManager
            ) -> Dict[str, Dict]:
                """Main function to decompose and execute a complex task"""
                
                # Create decomposer and executor
                decomposer = TaskDecomposer(config, team_manager)
                executor = TaskExecutor(team_manager)
                
                try:
                    # Decompose the task
                    print("Decomposing task...")
                    subtasks = decomposer.decompose_task(task)
                    
                    # Log the decomposition
                    print("\nTask Decomposition:")
                    for task in subtasks:
                        print(f"\nTask {task.id}:")
                        print(f"Description: {task.description.strip()}")
                        print(f"Required Agents: {', '.join(task.required_agents)}")
                        print(f"Dependencies: {', '.join(task.dependencies) if task.dependencies else 'none'}")
                    
                    # Execute subtasks
                    print("\nExecuting subtasks...")
                    results = executor.execute_subtasks(subtasks)
                    
                    return results
                    
                except Exception as e:
                    print(f"\nError in task decomposition/execution: {str(e)}")
                    return {"error": str(e)}            ==================================================

        ðŸ“„ executor.py
            File Contents:
            ==================================================
            import signal
            from contextlib import contextmanager
            from autogen.coding import DockerCommandLineCodeExecutor
            import tempfile
            import os
            
            class TimeoutException(Exception): pass
            
            @contextmanager
            def time_limit(seconds):
                def signal_handler(signum, frame):
                    raise TimeoutException("Timed out!")
                signal.signal(signal.SIGALRM, signal_handler)
                signal.alarm(seconds)
                try:
                    yield
                finally:
                    signal.alarm(0)
            
            class EnhancedDockerExecutor(DockerCommandLineCodeExecutor):
                def __init__(self, image: str, timeout: int = 30, workspace: str = None):
                    self.workspace = workspace or tempfile.mkdtemp()
                    os.makedirs(self.workspace, exist_ok=True)
                    super().__init__(
                        image=image,
                        timeout=timeout,
                        work_dir=self.workspace
                    )
                
                def execute_with_error_handling(self, code: str) -> str:
                    try:
                        with time_limit(self.timeout):
                            result = self.execute(code)
                            return result
                    except TimeoutException:
                        return "Execution timed out!"
                    except Exception as e:
                        return f"Error during execution: {str(e)}"            ==================================================

        ðŸ“„ teams.py
            File Contents:
            ==================================================
            from datetime import datetime
            from typing import Dict, List
            import uuid
            
            
            class TeamConfiguration:
                """Manages team compositions and agent relationships for workflows"""
                def __init__(self):
                    self.workflow_id = str(uuid.uuid4())
                    
                    # Team templates
                    self.research_team_template = {
                        "agents": [
                            {"role": "Research", "name": "Primary Researcher", "capabilities": ["data_analysis", "paper_review"]},
                            {"role": "Code", "name": "Research Assistant", "capabilities": ["implementation", "testing"]},
                            {"role": "QA", "name": "Review Specialist", "capabilities": ["verification", "validation"]},
                        ]
                    }
                    
                    self.development_team_template = {
                        "agents": [
                            {"role": "Code", "name": "Lead Developer", "capabilities": ["architecture", "implementation"]},
                            {"role": "QA", "name": "Test Engineer", "capabilities": ["testing", "quality"]},
                            {"role": "PM", "name": "Project Manager", "capabilities": ["coordination", "planning"]},
                            {"role": "Viz", "name": "UI Specialist", "capabilities": ["visualization", "design"]}
                        ]
                    }
                
                def get_team_types_and_roles(self) -> Dict[str, List[str]]:
                    """Get a dictionary of team types and their roles."""
                    return {
                        "research": [agent["role"] for agent in self.research_team_template["agents"]],
                        "development": [agent["role"] for agent in self.development_team_template["agents"]]
                    }
            
                def create_research_team(self) -> Dict:
                    """Create a research-focused team configuration"""
                    team_config = self._create_team_from_template(self.research_team_template)
                    
                    # Set up team-specific configurations
                    team_config["type"] = "research"
                    team_config["workflow_rules"] = {
                        "review_required": True,
                        "validation_steps": ["peer_review", "result_validation"],
                        "output_formats": ["paper", "code", "data"]
                    }
                    
                    return team_config
            
                def create_development_team(self) -> Dict:
                    """Create a development-focused team configuration"""
                    team_config = self._create_team_from_template(self.development_team_template)
                    
                    # Set up team-specific configurations
                    team_config["type"] = "development"
                    team_config["workflow_rules"] = {
                        "code_review_required": True,
                        "testing_required": True,
                        "deployment_steps": ["test", "stage", "prod"]
                    }
                    
                    return team_config
            
                def _create_team_from_template(self, template: Dict) -> Dict:
                    """Create a team configuration from a template"""
                    team_config = {
                        "id": self.workflow_id,
                        "created_at": datetime.now().isoformat(),
                        "status": "initializing",
                        "agents": [],
                        "connections": [],
                        "metrics": {
                            "tasks_completed": 0,
                            "messages_processed": 0,
                            "active_time": 0
                        }
                    }
                    
                    # Create agents from template
                    for agent_spec in template["agents"]:
                        agent_id = f"{agent_spec['role']}_{uuid.uuid4().hex[:8]}"
                        agent = {
                            "id": agent_id,
                            "name": agent_spec["name"],
                            "role": agent_spec["role"],
                            "capabilities": agent_spec["capabilities"],
                            "status": "ready",
                            "position": (0, 0)  # Will be set by node editor
                        }
                        team_config["agents"].append(agent)
                    
                    return team_config            ==================================================

        ðŸ“„ workflow.py
            File Contents:
            ==================================================
            from typing import Dict, List, Optional
            import queue
            import uuid
            from datetime import datetime
            
            from src.core.teams import TeamConfiguration
            from .config import SystemConfig
            
            class WorkflowManager:
                """Manages agent workflows and team coordination"""
                
                def __init__(self, config: SystemConfig, message_queue: queue.Queue):
                    self.config = config
                    self.message_queue = message_queue
                    self.active_workflows: Dict[str, Dict] = {}
                
                def create_workflow(self, workflow_type: str, task: str) -> str:
                    """Create a new workflow of specified type"""
                    workflow_id = str(uuid.uuid4())
                    
                    # Create workflow data structure
                    workflow_data = {
                        'id': workflow_id,
                        'type': workflow_type,
                        'status': 'initialized',
                        'task': task,
                        'created_at': datetime.now().isoformat(),
                        'agents': [],  # Will be populated when workflow starts
                        'interactions': [],
                        'team_config': None  # Will be set by main system
                    }
                    
                    self.active_workflows[workflow_id] = workflow_data
                    
                    # Notify monitor
                    if self.message_queue:
                        self.message_queue.put({
                            'type': 'new_workflow',
                            'workflow_id': workflow_id,
                            'data': workflow_data
                        })
                    
                    return workflow_id
                
                def start_workflow(self, workflow_id: str) -> None:
                    workflow = self.active_workflows.get(workflow_id)
                    if not workflow:
                        raise ValueError(f"Workflow not found: {workflow_id}")
                    
                    # Update workflow status
                    workflow['status'] = 'running'
                    
                    # Use agents from team configuration
                    team_config = workflow.get('team_config')
                    if team_config:
                        workflow['agents'] = team_config["agents"]
                    else:
                        # Handle the case where team_config is missing
                        pass
                    
                    self._update_workflow(workflow_id)
                    
                    # Start initial interaction
                    self._log_interaction(workflow_id, {
                        'from': 'system',
                        'to': 'all',
                        'message': f"Starting workflow: {workflow['task']}",
                        'timestamp': datetime.now().isoformat()
                    })
            
                
                def _log_interaction(self, workflow_id: str, interaction: Dict) -> None:
                    """Log an interaction in the workflow"""
                    workflow = self.active_workflows.get(workflow_id)
                    if workflow:
                        workflow['interactions'].append(interaction)
                        self._update_workflow(workflow_id)
                        
                        # Send message to monitor
                        if self.message_queue:
                            self.message_queue.put({
                                'type': 'message',
                                'content': f"{interaction['from']} â†’ {interaction['to']}: {interaction['message'][:100]}..."
                            })
                
                def _update_workflow(self, workflow_id: str) -> None:
                    """Send workflow update to monitor"""
                    if workflow_id in self.active_workflows and self.message_queue:
                        self.message_queue.put({
                            'type': 'workflow_update',
                            'workflow_id': workflow_id,
                            'data': self.active_workflows[workflow_id]
                        })            ==================================================

    ðŸ“ ui
        ðŸ“„ monitor.py
            File Contents:
            ==================================================
            # At the top of monitor.py
            import dearpygui.dearpygui as dpg
            import logging
            import queue
            import psutil
            import time
            from datetime import datetime
            from typing import Dict, List, Optional, Tuple, Any
            from dataclasses import dataclass
            from collections import defaultdict
            import docker
            import tkinter as tk
            import math
            
            from src.core.config import SystemConfig
            from src.core.workflow import WorkflowManager
            
            # Initialize logger
            logger = logging.getLogger(__name__)
            
            
            def get_screen_size_percentage(percentage=0.80):
                # Create a root window and hide it
                root = tk.Tk()
                root.withdraw()
            
                # Get the screen width and height
                screen_width = root.winfo_screenwidth()
                screen_height = root.winfo_screenheight()
            
                # Calculate the width and height based on the percentage
                width = int(screen_width * percentage)
                height = int(screen_height * percentage)
            
                # Destroy the root window
                root.destroy()
            
                return width, height
            
            logger = logging.getLogger(__name__)
            
            # src/ui/monitor.py
            
            import dearpygui.dearpygui as dpg
            import logging
            import queue
            import psutil
            import time
            from datetime import datetime
            from typing import Dict, List, Optional, Tuple, Any
            from dataclasses import dataclass
            import docker
            
            from src.core.config import SystemConfig
            from src.core.workflow import WorkflowManager
            
            logger = logging.getLogger(__name__)
            
            @dataclass
            class AgentState:
                """Represents the current state of an agent with enhanced type tracking"""
                name: str
                agent_type: str  # "Research", "Code", "Viz", "QA", "PM"
                role: str
                status: str
                tasks_completed: int
                memory_usage: float
                cpu_usage: float
                last_active: datetime
                position: Tuple[int, int] = (0, 0)
                current_task: Optional[str] = None
                specialization: Optional[str] = None
                performance_metrics: Dict[str, Any] = None
            
                @property
                def display_name(self) -> str:
                    """Returns a formatted display name including the agent type"""
                    return f"{self.name} ({self.agent_type})"
            
            class AgentMonitoringSystem:
                """Main monitoring system that handles UI and agent tracking"""
                
                def __init__(self, config: SystemConfig):
                    # Add debug logging
                    self.logger = logging.getLogger(__name__)
                    self.logger.setLevel(logging.DEBUG)
                    
                    # Create a console handler
                    ch = logging.StreamHandler()
                    ch.setLevel(logging.DEBUG)
                    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
                    ch.setFormatter(formatter)
                    self.logger.addHandler(ch)
                    
                    
                    # Basic state
                    self.config = config
                    self.message_queue = queue.Queue()
                    self.agents: Dict[str, AgentState] = {}
                    self.workflows: Dict[str, Dict] = {}
                    self.selected_workflow_id: Optional[str] = None
                    
                    # Performance tracking
                    self.agent_performance = defaultdict(list)
                    self.metrics = {
                        "messages_processed": 0,
                        "active_workflows": 0,
                        "tasks_completed": 0
                    }
                    
                    # Specialized agent tracking
                    self.research_agents = {}
                    self.code_agents = {}
                    self.viz_agents = {}
                    self.qa_agents = {}
                    self.pm_agents = {}
                    
                    self.agent_type_colors = {
                        "Research": (0, 150, 255, 255),  # Blue
                        "Code": (0, 255, 150, 255),      # Green
                        "Viz": (255, 150, 0, 255),       # Orange
                        "QA": (255, 0, 150, 255),        # Pink
                        "PM": (150, 0, 255, 255)         # Purple
                    }
                    
                    # Initialize components
                    self.workflow_manager = WorkflowManager(config, self.message_queue)
                    self.docker_client = docker.from_env()
                    
                    # UI state
                    self.width, self.height = get_screen_size_percentage()
                    
                    logging.info("AgentMonitoringSystem setup.")
            
                def setup_ui(self):
                    """Initialize the monitoring UI"""
                    try:
                        self.logger.debug("Starting UI setup")
                        
                        # Setup main window
                        with dpg.window(label="Agent Monitor", tag="primary_window", width=-1, height=-1):
                            self.logger.debug("Created primary window")
                            
                            with dpg.group(horizontal=True):
                                # Left panel - Controls and Status (25% of width)
                                left_width = int(self.width * 0.25)
                                with dpg.child_window(width=left_width, height=-1):
                                    self._setup_control_panel()
                                    self._setup_agent_list()
                                
                                with dpg.child_window(width=-1, height=-1):
                                    with dpg.tab_bar():
                                        with dpg.tab(label="Workflow View"):
                                            self._setup_node_editor()
                                        with dpg.tab(label="Metrics"):
                                            # self._setup_metrics_view()
                                            pass
                                        with dpg.tab(label="Message Log"):
                                            self._setup_message_log()
                                            pass
                        
                        self.logger.debug("UI setup complete")
                        
                        # Set as primary window
                        dpg.set_primary_window("primary_window", True)
                        
                    except Exception as e:
                        self.logger.error(f"Error in setup_ui: {str(e)}")
                        raise
            
                def _setup_control_panel(self):
                    """Setup workflow control panel"""
                    with dpg.collapsing_header(label="Workflow Control", default_open=True):
                        dpg.add_combo(
                            items=["research", "development", "viz"],
                            label="Workflow Type",
                            default_value="research",
                            tag="workflow_type"
                        )
                        
                        dpg.add_input_text(
                            label="Task Description",
                            multiline=True,
                            height=100,
                            tag="task_input"
                        )
                        
                        with dpg.group(horizontal=True):
                            dpg.add_button(
                                label="Start New Workflow",
                                callback=self.start_new_workflow,
                            )
                            
                            dpg.add_button(
                                label="Stop Selected",
                                callback=self.stop_selected_workflow,
                            )
            
                def run(self):
                    """Main application loop"""
                    try:
                        self.logger.debug("Starting main loop")
                        last_performance_update = time.time()
                        
                        while dpg.is_dearpygui_running():
                            try:
                                # Process messages
                                while not self.message_queue.empty():
                                    msg = self.message_queue.get_nowait()
                                    self.process_message(msg)
                                
                                # Update performances every second
                                current_time = time.time()
                                if current_time - last_performance_update >= 1.0:
                                    self.update_agent_performances()
                                    last_performance_update = current_time
                                
                                # Update other metrics and UI
                                self.update_metrics()
                                
                            except queue.Empty:
                                pass
                            except Exception as e:
                                self.logger.error(f"Error in main loop: {str(e)}")
                            
                            dpg.render_dearpygui_frame()
                            
                    except Exception as e:
                        self.logger.error(f"Error in run method: {str(e)}")
                        raise
                    
                def update_agent_performances(self):
                    """Update performance metrics for all agents"""
                    for agent_name, agent in self.agents.items():
                        try:
                            # Update CPU and memory usage (example values - replace with actual monitoring)
                            agent.cpu_usage = psutil.cpu_percent(interval=0.1)
                            agent.memory_usage = psutil.Process().memory_info().rss / 1024 / 1024  # MB
                            
                            # Update performance history
                            if not hasattr(agent, 'performance_history'):
                                agent.performance_history = [0.0] * 100
                            
                            # Add new value and maintain fixed length
                            agent.performance_history = agent.performance_history[1:] + [agent.cpu_usage]
                            
                            # Update the node
                            self._update_agent_node(agent)
                            
                        except Exception as e:
                            self.logger.error(f"Error updating agent {agent_name} performance: {e}")
                
                def stop_selected_workflow(self, sender, app_data):
                    """Stop the currently selected workflow"""
                    if self.selected_workflow_id:
                        try:
                            self.workflow_manager.stop_workflow(self.selected_workflow_id)
                            logger.info(f"Stopped workflow {self.selected_workflow_id}")
                        except Exception as e:
                            logger.error(f"Error stopping workflow: {e}")
                
                def _setup_status_panel(self):
                    """Setup system status panel"""
                    with dpg.collapsing_header(label="System Status", default_open=True):
                        dpg.add_text("Active Agents: 0", tag="active_agents_text")
                        dpg.add_text("Active Workflows: 0", tag="active_workflows_text")
                        dpg.add_text("Messages: 0", tag="messages_text")
                        dpg.add_text("Uptime: 00:00:00", tag="uptime_text")
            
                def _setup_visualization_tabs(self):
                    """Setup visualization tabs"""
                    with dpg.tab_bar():
                        # Workflow Graph Tab
                        with dpg.tab(label="Workflow Graph"):
                            self.graph_view = dpg.add_drawlist(
                                width=-1, 
                                height=int(self.height * 0.7)
                            )
                        
                        # Message Log Tab
                        with dpg.tab(label="Message Log"):
                            self.message_log = dpg.add_child_window(
                                width=-1,
                                height=int(self.height * 0.7)
                            )
                            # Add a clear button for the log
                            dpg.add_button(
                                label="Clear Log",
                                callback=lambda: dpg.delete_item(self.message_log, children_only=True),
                                parent=self.message_log
                            )
                        
                        # Metrics Tab
                        with dpg.tab(label="Metrics"):
                            self._setup_metrics_plot()
            
                def view_agent_details(self, sender, app_data):
                    """Show detailed information about selected agent"""
                    agent_name = dpg.get_value("agent_list")
                    if not agent_name:
                        return
                        
                    agent = self.agents.get(agent_name)
                    if not agent:
                        return
                    
                    # Create or configure the details window
                    if not dpg.does_item_exist("agent_details_window"):
                        with dpg.window(
                            label="Agent Details",
                            tag="agent_details_window",
                            pos=(int(self.width * 0.3), int(self.height * 0.3)),
                            width=400,
                            height=300,
                            show=True
                        ):
                            dpg.add_text("", tag="agent_details_text")
                    
                    # Update details text
                    details = f"""Name: {agent.get('name', 'N/A')}
                    Status: {agent.get('status', 'N/A')}
                    Role: {agent.get('role', 'N/A')}
                    Tasks Completed: {len(agent.get('tasks', []))}
                    Current Task: {agent.get('current_task', 'None')}"""
                        
                    dpg.configure_item("agent_details_text", default_value=details)
                    dpg.show_item("agent_details_window")
            
                def select_agent(self, sender, app_data):
                    """Handle agent selection from the list"""
                    selected_agent = self.agents.get(app_data)
                    if selected_agent:
                        logger.info(f"Selected agent: {app_data}")
                        # Update UI elements for selected agent
            
                def update_metrics(self):
                    """Update UI metrics - safe to call from render loop"""
                    if dpg.does_alias_exist("active_agents_text"):
                        dpg.set_value("active_agents_text", f"Active Agents: {len(self.agents)}")
                        dpg.set_value("active_workflows_text", f"Active Workflows: {self.metrics['active_workflows']}")
                        dpg.set_value("messages_text", f"Messages: {self.metrics['messages_processed']}")
            
                def update_graph(self):
                    """Update the workflow graph visualization - safe to call from render loop"""
                    if not self.selected_workflow_id:
                        return
            
                    workflow = self.workflows.get(self.selected_workflow_id)
                    if not workflow:
                        return
            
                    # Clear previous graph
                    dpg.delete_item(self.graph_view, children_only=True)
                    
                    # Draw nodes and edges
                    node_positions = {}
                    for agent in workflow['agents']:
                        x = len(node_positions) * 100 + 50
                        y = 200
                        node_positions[agent['name']] = (x, y)
                        
                        # Draw node
                        dpg.draw_circle((x, y), 20, parent=self.graph_view, fill=(0, 255, 0, 100))
                        dpg.draw_text((x-30, y+25), agent['name'], parent=self.graph_view)
            
                    # Draw edges for interactions
                    for interaction in workflow['interactions']:
                        if interaction['from'] in node_positions and interaction['to'] in node_positions:
                            start = node_positions[interaction['from']]
                            end = node_positions[interaction['to']]
                            dpg.draw_line(start, end, parent=self.graph_view, color=(255, 255, 255, 100))
            
                def process_message(self, message: Dict):
                    """Process incoming messages - safe to call from render loop"""
                    msg_type = message.get('type')
                    
                    if msg_type == 'new_agent':
                        self.agents[message['agent_id']] = message['data']
                        
                    elif msg_type == 'agent_update':
                        if message['agent_id'] in self.agents:
                            self.agents[message['agent_id']].update(message['data'])
                            
                    elif msg_type == 'new_workflow':
                        self.workflows[message['workflow_id']] = message['data']
                        self.metrics['active_workflows'] += 1
                        
                    elif msg_type == 'workflow_update':
                        if message['workflow_id'] in self.workflows:
                            self.workflows[message['workflow_id']].update(message['data'])
                            
                    elif msg_type == 'message':
                        self.metrics['messages_processed'] += 1
            
                    # Update UI elements
                    dpg.configure_item("agent_list", items=list(self.agents.keys()))
                    
                def select_workflow_callback(self, sender, app_data, user_data):
                    """Callback for when a workflow is selected in the UI"""
                    self.selected_workflow_id = user_data
                    self.update_views()
            
                def update_views(self):
                    """Update both graph and timeline views based on selected workflow"""
                    if self.selected_workflow_id and self.selected_workflow_id in self.active_workflows:
                        workflow = self.active_workflows[self.selected_workflow_id]
                        self.update_graph_view(workflow)
                        self.update_timeline_view(workflow)
            
                def update_graph_view(self, workflow: Dict):
                    """Update the graph visualization of agent interactions"""
                    if not self.graph_view_id:
                        return
            
                    # Create a directed graph
                    G = nx.DiGraph()
                    
                    # Add nodes for each agent
                    for agent in workflow['agents']:
                        G.add_node(agent['name'], role=agent['role'])
            
                    # Add edges for interactions
                    for interaction in workflow['interactions']:
                        G.add_edge(
                            interaction['from'],
                            interaction['to'],
                            timestamp=interaction['timestamp']
                        )
            
                    # Clear previous graph
                    dpg.delete_item(self.graph_view_id, children_only=True)
            
                    # Create layout
                    pos = nx.spring_layout(G)
                    
                    # Draw nodes
                    for node in G.nodes():
                        x, y = pos[node]
                        dpg.draw_circle(
                            center=[x * 100 + 200, y * 100 + 200],
                            radius=20,
                            fill=[0, 255, 0, 255],
                            parent=self.graph_view_id
                        )
                        dpg.draw_text(
                            pos=[x * 100 + 180, y * 100 + 190],
                            text=node,
                            parent=self.graph_view_id
                        )
            
                    # Draw edges
                    for edge in G.edges():
                        start_pos = pos[edge[0]]
                        end_pos = pos[edge[1]]
                        dpg.draw_line(
                            p1=[start_pos[0] * 100 + 200, start_pos[1] * 100 + 200],
                            p2=[end_pos[0] * 100 + 200, end_pos[1] * 100 + 200],
                            color=[255, 255, 255, 255],
                            parent=self.graph_view_id
                        )
            
                def update_timeline_view(self, workflow: Dict):
                    """Update the timeline visualization of agent activities"""
                    if not self.timeline_view_id:
                        return
            
                    # Clear previous timeline
                    dpg.delete_item(self.timeline_view_id, children_only=True)
            
                    # Sort interactions by timestamp
                    interactions = sorted(
                        workflow['interactions'],
                        key=lambda x: datetime.fromisoformat(x['timestamp'])
                    )
            
                    # Calculate timeline dimensions
                    timeline_start = datetime.fromisoformat(interactions[0]['timestamp'])
                    timeline_end = datetime.fromisoformat(interactions[-1]['timestamp'])
                    total_duration = (timeline_end - timeline_start).total_seconds()
            
                    # Draw timeline base
                    dpg.draw_line(
                        p1=[50, 250],
                        p2=[550, 250],
                        color=[255, 255, 255, 255],
                        parent=self.timeline_view_id
                    )
            
                    # Draw interactions on timeline
                    for idx, interaction in enumerate(interactions):
                        timestamp = datetime.fromisoformat(interaction['timestamp'])
                        position = (timestamp - timeline_start).total_seconds() / total_duration
                        x_pos = 50 + position * 500
            
                        # Draw marker
                        dpg.draw_circle(
                            center=[x_pos, 250],
                            radius=5,
                            fill=[0, 255, 0, 255],
                            parent=self.timeline_view_id
                        )
            
                        # Draw label
                        dpg.draw_text(
                            pos=[x_pos - 20, 260],
                            text=f"{interaction['from']} â†’ {interaction['to']}",
                            parent=self.timeline_view_id
                        )
            
                def register_workflow(self, workflow_id: str, workflow_data: Dict):
                    """Register a new workflow to be monitored"""
                    self.active_workflows[workflow_id] = workflow_data
                    if not self.selected_workflow_id:
                        self.selected_workflow_id = workflow_id
                        self.update_views()
            
                def update_workflow(self, workflow_id: str, workflow_data: Dict):
                    """Update an existing workflow's data"""
                    if workflow_id in self.active_workflows:
                        self.active_workflows[workflow_id] = workflow_data
                        if workflow_id == self.selected_workflow_id:
                            self.update_views()
                            
                def _setup_node_editor(self):
                    """Setup the node editor for agent visualization"""
                    with dpg.node_editor(
                        callback=self._on_node_connect,
                        delink_callback=self._on_node_disconnect,
                        minimap=True,
                        minimap_location=dpg.mvNodeMiniMap_Location_BottomRight,
                        tag="agent_node_editor"
                    ):
                        # Node editor will be populated dynamically
                        pass
                        
                    # Add a tooltip to explain controls
                    # with dpg.tooltip(parent="agent_node_editor"):
                    #     dpg.add_text("Ctrl+Click to remove connections\nDrag nodes to reposition")
            
            
                def _add_agent_node(self, agent: AgentState):
                    """Add a new agent node to the editor with proper styling and attributes"""
                    
                    # Generate unique node ID
                    node_id = f"node_{agent.name}"
                    
                    # Calculate initial position if not set
                    if agent.position == (0, 0):
                        num_nodes = len(self.agents)
                        x = 100 + (num_nodes % 3) * 250  # 3 columns
                        y = 100 + (num_nodes // 3) * 200  # 200px vertical spacing
                        agent.position = (x, y)
            
                    # Create node theme with agent-type specific colors
                    with dpg.theme() as node_theme:
                        with dpg.theme_component(dpg.mvNode):
                            color = self.agent_type_colors.get(agent.agent_type, (150, 150, 150, 255))
                            dpg.add_theme_color(dpg.mvNodeCol_TitleBar, color, category=dpg.mvThemeCat_Nodes)
                            dpg.add_theme_color(dpg.mvNodeCol_NodeOutline, color, category=dpg.mvThemeCat_Nodes)
            
                    # Create the node
                    with dpg.node(
                        label=f"{agent.agent_type} Agent: {agent.name}",
                        tag=node_id,
                        parent="agent_node_editor",
                        pos=agent.position
                    ):
                        # Bind the theme
                        dpg.bind_item_theme(node_id, node_theme)
                        
                        # Input attribute for receiving connections
                        with dpg.node_attribute(attribute_type=dpg.mvNode_Attr_Input, tag=f"input_{agent.name}"):
                            dpg.add_text("Input")
                            
                        # Static attributes for agent info
                        with dpg.node_attribute(attribute_type=dpg.mvNode_Attr_Static):
                            # Status indicator with color
                            status_colors = {
                                "active": [0, 255, 0, 255],    # Green
                                "idle": [150, 150, 150, 255],  # Gray
                                "busy": [255, 165, 0, 255],    # Orange
                                "error": [255, 0, 0, 255]      # Red
                            }
                            with dpg.group(horizontal=True):
                                dpg.add_text("Status: ")
                                dpg.add_text(
                                    agent.status,
                                    tag=f"status_text_{agent.name}",
                                    color=status_colors.get(agent.status.lower(), [255, 255, 255, 255])
                                )
            
                            # Add current task
                            dpg.add_text("Current Task:", tag=f"task_label_{agent.name}")
                            dpg.add_text(
                                agent.current_task or "None",
                                tag=f"task_text_{agent.name}",
                                wrap=300
                            )
            
                            # Add performance metrics
                            with dpg.group(horizontal=True):
                                dpg.add_text("CPU: ")
                                dpg.add_text(
                                    f"{agent.cpu_usage:.1f}%",
                                    tag=f"cpu_text_{agent.name}"
                                )
                            
                            with dpg.group(horizontal=True):
                                dpg.add_text("Memory: ")
                                dpg.add_text(
                                    f"{agent.memory_usage:.1f}MB",
                                    tag=f"memory_text_{agent.name}"
                                )
            
                            # Add mini performance plot
                            dpg.add_simple_plot(
                                label="Performance",
                                default_value=(0.0,) * 100,  # Initialize with zeros
                                width=200,
                                height=50,
                                tag=f"performance_plot_{agent.name}"
                            )
            
                        # Output attribute for making connections
                        with dpg.node_attribute(attribute_type=dpg.mvNode_Attr_Output, tag=f"output_{agent.name}"):
                            dpg.add_text("Output")
            
                        # Add right-click context menu
                        with dpg.popup(parent=node_id, mousebutton=dpg.mvMouseButton_Right):
                            dpg.add_menu_item(label="View Details", callback=lambda: self._view_agent_details())
                            dpg.add_menu_item(label="Reset Position", callback=lambda: self._reset_node_position(agent.name))
                            dpg.add_menu_item(label="Focus Agent", callback=lambda: self._focus_on_node(agent.name))
                
                def _focus_on_node(self, agent_name: str):
                    """Center the node editor view on a specific agent node"""
                    node_id = f"node_{agent_name}"
                    if dpg.does_item_exist(node_id):
                        pos = dpg.get_item_pos(node_id)
                        editor_pos = dpg.get_item_pos("agent_node_editor")
                        editor_size = dpg.get_item_rect_size("agent_node_editor")
                        
                        # Calculate center position
                        center_x = editor_pos[0] + editor_size[0]/2 - pos[0]
                        center_y = editor_pos[1] + editor_size[1]/2 - pos[1]
                        
                        # Smoothly pan to the node
                        dpg.set_node_editor_panning(center_x, center_y)
            
                
                def _update_agent_node(self, agent: AgentState):
                    """Update an existing agent node's information with enhanced error logging"""
                    try:
                        # Get all relevant item tags before updating
                        status_tag = f"status_text_{agent.name}"
                        task_tag = f"task_text_{agent.name}"
                        cpu_tag = f"cpu_text_{agent.name}"
                        memory_tag = f"memory_text_{agent.name}"
                        plot_tag = f"performance_plot_{agent.name}"
            
                        # Log the items we're trying to update
                        self.logger.debug(f"Updating node items for agent {agent.name}: "
                                        f"status={status_tag}, task={task_tag}, "
                                        f"cpu={cpu_tag}, memory={memory_tag}, plot={plot_tag}")
            
                        # Check if items exist before updating
                        for tag in [status_tag, task_tag, cpu_tag, memory_tag, plot_tag]:
                            if not dpg.does_item_exist(tag):
                                self.logger.error(f"Item {tag} does not exist!")
                                continue
            
                            try:
                                # Status update
                                if tag == status_tag:
                                    status_colors = {
                                        "active": [0, 255, 0, 255],
                                        "idle": [150, 150, 150, 255],
                                        "busy": [255, 165, 0, 255],
                                        "error": [255, 0, 0, 255]
                                    }
                                    dpg.configure_item(
                                        tag,
                                        default_value=agent.status,
                                        color=status_colors.get(agent.status.lower(), [255, 255, 255, 255])
                                    )
                                    self.logger.debug(f"Updated status for {agent.name}: {agent.status}")
            
                                # Task update
                                elif tag == task_tag:
                                    dpg.configure_item(
                                        tag,
                                        default_value=agent.current_task or "None"
                                    )
                                    self.logger.debug(f"Updated task for {agent.name}: {agent.current_task}")
            
                                # CPU update
                                elif tag == cpu_tag:
                                    dpg.configure_item(
                                        tag,
                                        default_value=f"{agent.cpu_usage:.1f}%"
                                    )
                                    self.logger.debug(f"Updated CPU for {agent.name}: {agent.cpu_usage:.1f}%")
            
                                # Memory update
                                elif tag == memory_tag:
                                    dpg.configure_item(
                                        tag,
                                        default_value=f"{agent.memory_usage:.1f}MB"
                                    )
                                    self.logger.debug(f"Updated memory for {agent.name}: {agent.memory_usage:.1f}MB")
            
                                # Performance plot update
                                elif tag == plot_tag and hasattr(agent, 'performance_history'):
                                    dpg.configure_item(
                                        tag,
                                        default_value=agent.performance_history
                                    )
                                    self.logger.debug(f"Updated performance plot for {agent.name}")
            
                            except Exception as item_error:
                                # Get DPG's last error
                                self.logger.error(f"Error updating {tag} for agent {agent.name}:")
                                self.logger.error(f"Exception: {str(item_error)}")
                                if hasattr(item_error, '__traceback__'):
                                    import traceback
                                    self.logger.error("Traceback:")
                                    self.logger.error(traceback.format_tb(item_error.__traceback__))
            
                    except Exception as e:
                        # Get DPG's last error
                        self.logger.error(f"Critical error updating agent node {agent.name}:")
                        self.logger.error(f"Exception: {str(e)}")
                        if hasattr(e, '__traceback__'):
                            import traceback
                            self.logger.error("Traceback:")
                            self.logger.error(traceback.format_tb(e.__traceback__))
            
                def setup_logging(self):
                    """Setup enhanced logging configuration"""
                    # Create a formatter that includes more details
                    formatter = logging.Formatter(
                        '%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s'
                    )
                    
                    # Create console handler with formatter
                    console_handler = logging.StreamHandler()
                    console_handler.setFormatter(formatter)
                    
                    # Create file handler with formatter
                    file_handler = logging.FileHandler('agent_monitor.log')
                    file_handler.setFormatter(formatter)
                    
                    # Get logger and add handlers
                    self.logger = logging.getLogger(__name__)
                    self.logger.addHandler(console_handler)
                    self.logger.addHandler(file_handler)
                    self.logger.setLevel(logging.DEBUG)
                    
                    # Also log DPG version and initialization
                    self.logger.info(f"DearPyGui Version: {dpg.get_dearpygui_version()}")
                    self.logger.info("Initializing Agent Monitoring System")
            
                def _get_role_color(self, role: str) -> tuple:
                    """Get color theme for different agent roles"""
                    colors = {
                        "research": (0, 150, 255, 255),   # Blue
                        "code": (0, 255, 150, 255),       # Green
                        "viz": (255, 150, 0, 255),        # Orange
                        "qa": (255, 0, 150, 255),         # Pink
                        "pm": (150, 0, 255, 255)          # Purple
                    }
                    return colors.get(role.lower(), (150, 150, 150, 255))
            
                def _on_node_connect(self, sender, app_data):
                    """Handle connection between agent nodes"""
                    try:
                        # Extract source and target node IDs
                        source_attr_id, target_attr_id = app_data
                        source_agent = source_attr_id.split('_')[1]
                        target_agent = target_attr_id.split('_')[1]
            
                        # Create the link
                        link_id = dpg.add_node_link(source_attr_id, target_attr_id, parent=sender)
            
                        # Log the connection
                        self.log_message(
                            f"Connected {self.agents[source_agent].agent_type} agent '{source_agent}' to "
                            f"{self.agents[target_agent].agent_type} agent '{target_agent}'",
                            "info"
                        )
            
                        # Update workflow connections
                        if self.selected_workflow_id:
                            self._add_workflow_connection(source_agent, target_agent)
            
                    except Exception as e:
                        self.logger.error(f"Error creating node connection: {e}")
                        
                
                def _reset_node_position(self, agent_name: str):
                    """Reset an agent node to its default position"""
                    node_id = f"node_{agent_name}"
                    if dpg.does_item_exist(node_id):
                        num_nodes = len(self.agents)
                        x = 100 + (num_nodes % 3) * 250
                        y = 100 + (num_nodes // 3) * 200
                        dpg.set_item_pos(node_id, [x, y])
            
                def _add_workflow_connection(self, source_agent: str, target_agent: str):
                    """Add a connection to the current workflow"""
                    if self.selected_workflow_id and self.selected_workflow_id in self.workflows:
                        workflow = self.workflows[self.selected_workflow_id]
                        workflow['connections'].append({
                            'from': source_agent,
                            'to': target_agent,
                            'timestamp': datetime.now().isoformat()
                        })
            
                def _on_node_disconnect(self, sender, app_data):
                    """Handle disconnection between agent nodes"""
                    try:
                        # Extract node IDs from attribute IDs
                        from_node = app_data[0].split('_')[1]
                        to_node = app_data[1].split('_')[1]
                        
                        # Log the disconnection
                        self.log_message({
                            'type': 'System',
                            'content': f'Connection removed between {from_node} and {to_node}'
                        })
                        
                        # Update workflow connections
                        if self.selected_workflow_id:
                            workflow = self.workflows.get(self.selected_workflow_id)
                            if workflow:
                                workflow['connections'] = [
                                    conn for conn in workflow['connections']
                                    if not (conn['from'] == from_node and conn['to'] == to_node)
                                ]
                                self._update_workflow(self.selected_workflow_id, workflow)
                        
                    except Exception as e:
                        logger.error(f"Error handling node disconnection: {e}")
            
                def _auto_layout_nodes(self):
                    """Automatically arrange nodes in a force-directed layout"""
                    try:
                        if not self.selected_workflow_id:
                            return
                            
                        workflow = self.workflows.get(self.selected_workflow_id)
                        if not workflow:
                            return
                        
                        # Create networkx graph from connections
                        G = nx.Graph()
                        
                        # Add nodes
                        for agent in workflow['agents']:
                            G.add_node(agent['id'])
                        
                        # Add edges
                        for conn in workflow['connections']:
                            G.add_edge(conn['from'], conn['to'])
                        
                        # Calculate layout
                        pos = nx.spring_layout(G)
                        
                        # Scale and translate positions to fit in the node editor
                        editor_width = dpg.get_item_width("agent_node_editor")
                        editor_height = dpg.get_item_height("agent_node_editor")
                        margin = 50
                        
                        for node_id, position in pos.items():
                            x = (position[0] + 1) * (editor_width - 2*margin)/2 + margin
                            y = (position[1] + 1) * (editor_height - 2*margin)/2 + margin
                            dpg.set_item_pos(f"node_{node_id}", [x, y])
                        
                    except Exception as e:
                        logger.error(f"Error in auto-layout: {e}")
            
                def _add_node_context_menu(self):
                    """Add context menu for nodes"""
                    with dpg.handler_registry():
                        dpg.add_item_clicked_handler(callback=self._show_node_context_menu, button=dpg.mvMouseButton_Right)
            
                def _show_node_context_menu(self, sender, app_data, user_data):
                    """Show context menu for node interactions"""
                    if dpg.does_item_exist("node_context_menu"):
                        dpg.delete_item("node_context_menu")
                    
                    # Get clicked node
                    clicked_node = dpg.get_item_info(sender)["parent"]
                    if not clicked_node.startswith("node_"):
                        return
                        
                    node_id = clicked_node.split("_")[1]
                    
                    # Create context menu
                    with dpg.window(label="Node Menu", tag="node_context_menu", popup=True):
                        dpg.add_text(f"Node: {node_id}")
                        dpg.add_separator()
                        
                        # Add menu items
                        dpg.add_menu_item(
                            label="View Details",
                            callback=lambda: self.view_agent_details(node_id)
                        )
                        dpg.add_menu_item(
                            label="Reset Position",
                            callback=lambda: dpg.reset_pos(clicked_node)
                        )
                        dpg.add_menu_item(
                            label="Remove Node",
                            callback=lambda: self._remove_agent_node(node_id)
                        )
            
                def _remove_agent_node(self, agent_id: str):
                    """Remove an agent node from the editor"""
                    try:
                        # Remove from workflow
                        if self.selected_workflow_id:
                            workflow = self.workflows.get(self.selected_workflow_id)
                            if workflow:
                                workflow['agents'] = [
                                    agent for agent in workflow['agents']
                                    if agent['id'] != agent_id
                                ]
                                workflow['connections'] = [
                                    conn for conn in workflow['connections']
                                    if conn['from'] != agent_id and conn['to'] != agent_id
                                ]
                                self._update_workflow(self.selected_workflow_id, workflow)
                        
                        # Remove node from editor
                        dpg.delete_item(f"node_{agent_id}")
                        
                        self.log_message({
                            'type': 'System',
                            'content': f'Removed agent {agent_id} from workflow'
                        })
                        
                    except Exception as e:
                        logger.error(f"Error removing agent node: {e}")
                        
            
                def _setup_message_log(self):
                    """Setup the message log panel"""
                    with dpg.child_window(label="Message Log", height=-1):
                        # Add message filter controls
                        with dpg.group(horizontal=True):
                            dpg.add_combo(
                                label="Filter",
                                items=["All", "Info", "Warning", "Error"],
                                default_value="All",
                                callback=self._filter_messages,
                                tag="message_filter"
                            )
                            dpg.add_button(label="Clear", callback=self._clear_messages)
                        
                        # Message log container
                        dpg.add_child_window(tag="message_list", height=-1)
            
                def _setup_agent_list(self):
                    """Enhanced agent list setup with type information"""
                    with dpg.collapsing_header(label="Agent List", default_open=True):
                        # Add agent type filter
                        dpg.add_combo(
                            label="Filter by Type",
                            items=["All", "Research", "Code", "Viz", "QA", "PM"],
                            default_value="All",
                            callback=self._filter_agents,
                            tag="agent_type_filter"
                        )
                        
                        # Enhanced listbox with agent types
                        dpg.add_listbox(
                            tag="agent_list",
                            items=[],
                            num_items=10,
                            callback=self._on_agent_selected,
                            width=-1
                        )
            
                def _on_agent_selected(self, sender, app_data):
                    """Handle agent selection from list"""
                    self.selected_agent_id = app_data
                    self._view_agent_details()
                    self.logger.debug(f"Selected agent: {app_data}")
            
                def _get_agent_type_for_workflow(self, workflow_type: str) -> str:
                    """Determine appropriate agent type based on workflow type"""
                    type_mapping = {
                        "research": "Research",
                        "development": "Code",
                        "viz": "Viz",
                        "qa": "QA",
                        "management": "PM"
                    }
                    return type_mapping.get(workflow_type.lower(), "Code")
            
                def _view_agent_details(self):
                    """Enhanced agent details view"""
                    if not hasattr(self, 'selected_agent_id'):
                        return
                        
                    agent = self.agents.get(self.selected_agent_id)
                    if not agent:
                        return
                    
                    # Create or update details window with enhanced information
                    if not dpg.does_item_exist("agent_details_window"):
                        with dpg.window(
                            label="Agent Details",
                            tag="agent_details_window",
                            pos=(int(self.width * 0.3), int(self.height * 0.3)),
                            width=400,
                            height=300,
                            show=True
                        ):
                            # Add collapsing headers for organized information
                            with dpg.collapsing_header(label="Basic Info", default_open=True):
                                dpg.add_text("", tag="agent_basic_info")
                                
                            with dpg.collapsing_header(label="Performance", default_open=True):
                                dpg.add_text("", tag="agent_performance")
                                
                            with dpg.collapsing_header(label="Tasks", default_open=True):
                                dpg.add_text("", tag="agent_tasks")
                    
                    # Update information sections
                    basic_info = (
                        f"Agent ID: {agent.name}\n"
                        f"Type: {agent.agent_type}\n"
                        f"Role: {agent.role}\n"
                        f"Status: {agent.status}"
                    )
                    dpg.set_value("agent_basic_info", basic_info)
                    
                    performance_info = (
                        f"CPU Usage: {agent.cpu_usage:.1f}%\n"
                        f"Memory Usage: {agent.memory_usage:.1f}MB\n"
                        f"Last Active: {agent.last_active.strftime('%H:%M:%S')}"
                    )
                    dpg.set_value("agent_performance", performance_info)
                    
                    tasks_info = (
                        f"Tasks Completed: {agent.tasks_completed}\n"
                        f"Current Task: {agent.current_task or 'None'}"
                    )
                    dpg.set_value("agent_tasks", tasks_info)
                    
                    dpg.show_item("agent_details_window")
                    
                def _filter_agents(self, sender, app_data):
                    """Filter agents by type"""
                    selected_type = app_data
                    if selected_type == "All":
                        self._update_agent_list()
                    else:
                        filtered_agents = {
                            name: agent for name, agent in self.agents.items()
                            if agent.agent_type == selected_type
                        }
                        agent_items = [agent.display_name for agent in filtered_agents.values()]
                        dpg.configure_item("agent_list", items=agent_items)
            
                def start_new_workflow(self, sender, app_data):
                    """Enhanced workflow creation with proper agent type assignment"""
                    try:
                        workflow_type = dpg.get_value("workflow_type")
                        task = dpg.get_value("task_input")
                        
                        if not task.strip():
                            self.log_message("Task description required", "error")
                            return
                        
                        # Create workflow
                        workflow_id = self.workflow_manager.create_workflow(
                            workflow_type=workflow_type,
                            task=task
                        )
                        
                        # Determine appropriate agent type based on workflow
                        agent_type = self._get_agent_type_for_workflow(workflow_type)
                        
                        # Create agent with proper type
                        agent = AgentState(
                            name=f"agent_{len(self.agents)}",
                            agent_type=agent_type,
                            role=workflow_type,
                            status="active",
                            tasks_completed=0,
                            memory_usage=0.0,
                            cpu_usage=0.0,
                            last_active=datetime.now(),
                            current_task=task
                        )
                        self.agents[agent.name] = agent
                        
                        # **Add this line to create the agent node in the UI**
                        self._add_agent_node(agent)
                        
                        # Update UI
                        self._update_agent_list()
                        self.log_message(f"Started new {workflow_type} workflow with {agent_type} agent: {workflow_id}", "info")
                        
                    except Exception as e:
                        self.logger.error(f"Error starting workflow: {e}")
                        self.log_message(f"Error starting workflow: {str(e)}", "error")
            
            
            
                def _update_agent_list(self):
                    """Update the agent list with type information"""
                    if dpg.does_item_exist("agent_list"):
                        # Format agent names to include their types
                        agent_items = [
                            agent.display_name
                            for agent in self.agents.values()
                        ]
                        dpg.configure_item("agent_list", items=agent_items)
            
                def log_message(self, message: str, level: str = "info"):
                    """Add a message to the log"""
                    timestamp = datetime.now().strftime("%H:%M:%S")
                    with dpg.mutex():
                        if dpg.does_item_exist("message_list"):
                            dpg.add_text(
                                f"[{timestamp}] {level.upper()}: {message}",
                                parent="message_list",
                                color=self._get_message_color(level)
                            )
            
                def _get_message_color(self, level: str) -> tuple:
                    """Get color for different message types"""
                    colors = {
                        "info": (255, 255, 255),    # White
                        "success": (0, 255, 0),     # Green
                        "warning": (255, 255, 0),   # Yellow
                        "error": (255, 0, 0)        # Red
                    }
                    return colors.get(level, (255, 255, 255))
            
                def _clear_messages(self):
                    """Clear all messages from the log"""
                    if dpg.does_item_exist("message_list"):
                        dpg.delete_item("message_list", children_only=True)
            
                def _filter_messages(self, sender, app_data):
                    """Filter messages based on level"""
                    # To be implemented when we add message storage
                    pass            ==================================================

